<!DOCTYPE HTML>
<html>
<head>
	<title></title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #000000;
		}
        #canvasArea {
            margin-left: auto;
            margin-right: auto;        
        }
        
        #betaText {
            margin-left: auto;
            margin-right: auto;  
            width: 800px;
            text-align:center;
            color:#aaaaaa;
            font-size:0.6em;
            font-family:"Verdana", Sans-serif;
        }
        
        #betaText a {
            color:#aaaaFF;
            text-decoration: none;
            border-bottom: 1px dotted rgb(148, 113, 183);
        }
        <!-- GDJS_CUSTOM_STYLE -->
	</style>
    <!-- Libs and GDJS core files : -->
	<!-- GDJS_CODE_FILES -->

</head>
<body>
    <div id="canvasArea"></div>

    <!-- GDJS_CUSTOM_HTML -->
	<script>
    
    (function() {
        var isMSIE = /*@cc_on!@*/0;

        gdjs.registerObjects();
        gdjs.registerAutomatisms();

        var game = new gdjs.RuntimeGame(gdjs.projectData.Project);
    
        //Create a renderer
        var canvasWidth = parseInt(gdjs.projectData.Project.Info.WindowW.attr.value); 
        var canvasHeight = parseInt(gdjs.projectData.Project.Info.WindowH.attr.value); 
        var renderer = PIXI.autoDetectRenderer(canvasWidth, canvasHeight);
        var canvasArea = document.getElementById("canvasArea");
        //Manage canvas position. TODO: Factor this into a function and manage window resizing.
        canvasArea.style["padding-top"] = (gdjs.getDocHeight()-canvasHeight)/2+"px";
        canvasArea.style.width = canvasWidth+"px";
        canvasArea.style.height = canvasHeight+"px";
        canvasArea.appendChild(renderer.view); // add the renderer view element to the DOM
        canvasArea.tabindex="1";
        
        //Bind keyboards and mouse events
        document.onkeydown = function(e) {
            game.onKeyPressed(e.keyCode);
        };
        document.onkeyup = function(e) {
            game.onKeyReleased(e.keyCode);
        };
        renderer.view.onmousemove = function(e){
            game.onMouseMove(e.pageX-canvasArea.getBoundingClientRect().left, 
                             e.pageY-canvasArea.getBoundingClientRect().top);
        }; 
        renderer.view.onmousedown = function(e){
            game.onMouseButtonPressed(e.button === 2 ? 1 : 0);
            return false;
        };
        renderer.view.onmouseup = function(e){
            game.onMouseButtonReleased(e.button === 2 ? 1 : 0);
            return false;
        };
        renderer.view.onmouseout = function(e){
            game.onMouseButtonReleased(0);
            game.onMouseButtonReleased(1);
            game.onMouseWheel(0);
            return false;
        };
        window.addEventListener('click', function(e) {
            e.preventDefault();
            return false;
        }, false);
        renderer.view.oncontextmenu = function(event) {
            event.preventDefault();
            event.stopPropagation();
            return false;
        };
        renderer.view.onmousewheel = function (event){
            game.onMouseWheel(event.wheelDelta);
        }
        
        /*if ( !game.hasScene() ) {
            console.log("The game has no scene.");
            return;
        }*/
        
        //Load all assets
        var loadingStage = new PIXI.Stage();
        var text = new PIXI.Text(" ", {font: "bold 60px Arial", fill: "#FFFFFF", align: "center"});
        loadingStage.addChild(text);
        text.position.x = canvasWidth/2-50;
        text.position.y = canvasHeight/2;
        var loadingCount = 0;
        
        var assets = [];
        gdjs.iterateOver(gdjs.projectData.Project.Resources.Resources, "Resource", function(res) {
            if ( res.attr.file ) {
                assets.push(res.attr.file);
            }
            console.log(res.attr.file);
        });
        
        if ( assets.length !== 0 ) {
            var assetLoader = new PIXI.AssetLoader(assets);
            assetLoader.onComplete = onAssetsLoaded;
            assetLoader.onProgress = onAssetsLoadingProgress;
            assetLoader.load();
        }
        else {
            onAssetsLoaded();
        }
        
        function onAssetsLoaded() {
            //Create the scene to be played
            var currentScene = new gdjs.RuntimeScene(game, renderer);
            var firstSceneName = gdjs.projectData.Project.Scenes.attr.firstScene;
            var firstsceneData = game.hasScene(firstSceneName) ? game.getSceneData(firstSceneName) : game.getSceneData();
                
            currentScene.loadFromScene(firstsceneData);
            
            requestAnimFrame( gameLoop );
            
            function gameLoop() {
                if ( !currentScene.renderAndStep() ) {
                    if ( currentScene.gameStopRequested() )
                        postGameScreen();
                    else {
                        var nextSceneName = currentScene.getRequestedScene();
                        currentScene = new gdjs.RuntimeScene(game, renderer);
                        currentScene.loadFromScene(game.getSceneData(nextSceneName));
                        requestAnimFrame( gameLoop );
                    }   
                }
                else { 
                    requestAnimFrame( gameLoop );
                }
            }
        }
        
        function onAssetsLoadingProgress() {
            renderer.render(loadingStage);
            loadingCount++;
            text.setText(Math.floor(loadingCount/assets.length*100) + "%");
        }
        
        function postGameScreen() {
            //TODO
        }
    })();

	</script>
	</body>
</html>
